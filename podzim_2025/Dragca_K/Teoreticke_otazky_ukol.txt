Teoretické otázky

 1. Proč je vhodné nastavit uživatelské jméno a e-mail hned po instalaci?
 - aby bylo dohledatelné, kdo udělal kterou změnu. Což je v týmovém projektu žádoucí 
 2. Jaký je rozdíl mezi pracovním adresářem, indexem (staging area) a repozitářem?
 pracovní adresář - místo na disku, kde pracuji se soubory (vytvářím, mažu, edituju...)
 index(staging area) - dočasné uložiště změn, které budu commitovat
 git add nazev souboru
 repozitář - místo, kde git ukládá historii změn
 Je to vnitřní databáze Gitu, kde se trvale ukládají commity a historie projektu. Git ukládá každý commit jako „snímek“ aktuálního stavu (snapshot).
Tato databáze je ve skryté složce .git/ uvnitř projektu(uvniř adresáře projektu na disku, zakládá se git init.
 PRACOVNÍ ADRESÁŘ → (git add) → INDEX → (git commit) → REPOZITÁŘ
 
 3. Co se děje při příkazu git add a co při git commit?
 git add - přídá změny do indexu(staging area), připravuji si změnu nebo soubor ke commitu
 git add soubor.txt - přidán jeden soubor
 git add . - přidá všechny změny
 !!git add neukládá změny do historie, jen je připraví
 git commit vezme změny ze staging area a uloží je do repozitáře jako nový commit 
 git commit -m "Přidal jsem nový soubor"
git uloží obraz těchto změn do své databáze(.git/)
 4. Vysvětli, co je to commit hash a proč je důležitý.
 Unikátní označení revize(commitu), pomocí kterého se vždy bude dát dostat k této konkrétní verzi projektu.
je to 40místný kód vygenerovaný pomocí SHA-1 hashovací funkce,jednoznačné identifikuje každou revizi (verzi).
 5. Jak Git uchovává historii změn? Uveď rozdíl oproti klasickému ukládání souborů.
 git ukládá změny jako snapshoty(snímky) celého projektu v čase, neduplikuje obsah, ukládá pouze změny a nový commit odkazuje na předchozí commit a tím vzniká historie. Lze se vrátit ke každé předchozí verzi, komprimuje změny efektivně (neduplikuje)
 6. Co znamená, že Git je „distribuovaný systém pro správu verzí“?
 Každý z vývojářů/uživatelů má u sebe kompletní plnohodnotnou verzi repozitáře projektu s celou historií a může na projektu pracovat nezávisle na připojení k nějakému centrálnímu serveru.
 7. Proč je doporučeno používat větve místo práce přímo v hlavní větvi (main/master)?
Je výhodné udržovat master/main ve funkční verzi a změny provádět ve vedlejší větvi a sloučit je do main až, když jsem spokojen.Díkz tomu může pracovat na různých úpravách paralelně více lidí a main zůstává stále funkční a stabilní, až je změna otestovaná, funkční, schválená, zmerguje se do main. Nebo se taky může od změny ustoupit a větev se pak jednoduše smaže. Main zůstává stále funkční.
 8. Jaký je rozdíl mezi git merge a git rebase? Uveď příklad, kdy bys použil/a který. Co se stane s historií, pokud sloučíš větev pomocí merge? A co při rebase? Pozn.: Co je rebase jsme se na kurzu neučili, ale jde taky o způsob slučování větví, který je dobré znát. Zkus si o tom dohledat informace.
 Git merge používáme k začlenení úprav provedených ve větvích do main, při použití git merge se zachová historie včetně větví. 
 Git rebase- při tomto použití se změny větvi zařadí za main, vzpadá to, jako kdyby vznikly z main.. historie je lineární.- nesmí se používat na veřejných větvích. 
9.  Jaký je účel pull requestu a proč se používá?
je to žádost o začlenění mnou provedených změn z mé kopie repozitáře y mé větve funkce do hlavního repozitáře autorů projektu. Umožňuje spolupráci více lidí na jednom projektu a do stabilní verze main projektu jsou tyto změny přidány až po schválení autory. 
10. Co znamená code review a jaký je jeho přínos?
kodová kontrola, zpravidla během pull requestu, kolegové si mohou projít  změnz řádek po řádku, mohou yanechat komentáře, návrhy, připomínky, zvyšuje kvalitu kódu a snižuje počet chyb. 
11. K čemu je soubor .gitignore ?
je to speciální soubor, do kterého zapisujeme soubory nebo složky, které nemá Git sledovat (trackovat) a nemá je zahrnovat do commitů.
repozitář zůstává čistý a přehledný, Git nesleduje stovky zbytečných souborů.
12. Co se stane, pokud přidáš do .gitignore soubor, který už je ve verzovací historii?
Git ho NEPŘESTANE sledovat automaticky.
Přestože je uvedený v .gitignore, zůstává sledovaný, dokud ho ručně neodstraníš z indexu.
13. Proč je vhodné ignorovat logy, dočasné soubory editorů nebo sestavení?
Nejsou součástí zdrojového kódu, zbytečně by nafukovaly repozitář, dočasné soubory se čast mění.
Logy - Velké, mění se, nikdo je nepotřebuje verzovat
Soubory editorů - Osobní nastavení, nepatří do repozitáře
Sestavení (build) - Vygenerované, dá se je znovu vytvořit
Dočasné soubory- Nepodstatné pro projekt, vznikají automaticky
14. Jak se zapisují vzory do .gitignore? Uveď příklady pro:
        ignorování všech .log souborů - *.log
        ignorování adresáře build - build/
        ignoruje všechny složky build kdekoliv v projektu - **/build/
        *.tmp - Ignoruje všechny dočasné .tmp soubory
        !important.log - NEignoruje soubor important.log (výjimka)

